{\rtf1\ansi\ansicpg1252\cocoartf1265\cocoasubrtf210
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fswiss\fcharset0 Helvetica-Light;\f2\froman\fcharset0 Times-Roman;
}
{\colortbl;\red255\green255\blue255;}
\margl1440\margr1440\vieww13640\viewh11740\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural

\f0\fs24 \cf0 # 3 Cache ? su98 final dis8 su14\
Ex1:1MB cache with 64B blocks, 4-way associative, write-through with LRU replacement. Assume 36 bit byte addressable address space.\
Capacity of 1MB = 2^20 bytes, Block size of 64B = 2^6 bytes, associativity of = 4 = 2^2. \
offset = log2(block size) = 6.\
To find set field(index) we need to determine # of rows. To find # of rows we need to find # of blocks. Since we know its 4 set ass. each set has four blocks (# of ways maybe this refers too?).\
#Blocks = Capacity / blocksize = 2^20 / 2^6 = 2^14\
#Sets = #Blocks / #ways = 2^14 / 2 ^2 = 2^12, so set is 12.\
32 -12 - 6 = 14 Tag.\
Capacity = 32 KiB = (2^10 = 1KiB) * 2^5\
Blocksize = 16B = 2^4.\
offset = 4.\
ways = 4 = 2^2    #blocks  = Capacity / Blocksize =  2^15 / 2^4 = 2^11. #sets = 2^11 / 2^2 = 2^9 \
9 set. tag = 32 - 9 - 4 = 19. \
\
point 2: A, B, C\'85 since they have same index since it would keep getting discarded(I dunno ask)\
\
AMAT = 1 + 3  x 1=  4 cycles.\
and yes it will be improved by random.\
00010 = 2 * 2^2     n << 2 or 2 << n\
\
CS61C su14 mid. review\
int exp = getExp(num) + n ;\
if (exp > )    hex representation of 2^38   //stupid its if  exp > getExp(38)  \
if (exp < )  hex repr. of 2^-38  // exp < getExp(-38)\
num = getExp(num) ^ 0 //don\'92t know if its this or getExp(num) >> num(or number of bits need to move right (maybe n?))\
return exp * 2 <<n?;\
investigate slide 11\
\
for slide 18 ex.     1011 -> 0111  & 0110  \'97 1100\
*p = (*p << n) | (*p >> (sizeof(int)*8 - n))   //why times 8 and why subtract n\
mips slide 22\
IsNotInfinity:  sll $a0, $a0, 1 //remove the sign\
		xori $v0, $a0, 0xFF000000 //becomes 0 if both bits in spot n are 0 or 1 (both)\
		jr $ra  \
\
\pard\pardeftab720\sa240

\f1\fs28 \cf0 the only I-types that zero-extend their immediate values are andi, ori, & xori\
add operation (mips) only detects signed overflow
\f2  \
the reach would be two less\
to calc. number of cycles do the same to cal. aver. CPI but instead change the instances being tested, for some reason in slide 49 I divide by two the instance I am checking its # of cycles\
# of bits per row = # of block bytes * # of rows + #tag bits + i think # of indices(ex. if index is 1 result is 2^1 = 2) (or valid bit?)\
need help understanding for loop code on cache\
answers for review:\
2^32 = 4 GiB byte addressed memory\
# of total words in memory =  size of addressed memory / byte words = 2^32 / 2^3 = 2^\ul 29\ulnone  words\
2^3 is from 8 byte words. So 29 bits needed for address. Since we are know word addressed to get 4 words we need 2^2, so two bits of offset. 2^8 = 256\
its 2^5 since a word is 32 bits\
# of rows in cache is 2^18 / 2^5 = 2^13 so index is 13\
29 - 13 -2 =  14 tag bits.\
//NO HIT RATE IN EQUATION ONLY MISS RATE \'97\'97 MR = 1 - HR\
//side note never cons. additions its always x then + then x or other way around\
AMAT = 3 + .25 * (10 + .40 + (100)) + 1000 * .9 = \
apple opportunity for web development in fall\
its posted in Facebook in CS Jobs & Internships email resume to recruiter esabochik@apple.com\
posted by Winny Huang look for it tomorrow  \
\
in resume put under skills Java Server Pages/Servlets\
\
si si, que crees un Componente de Imagen\
que podas mostrar una imagen\
que est\'e1 almacena en el DAM\
es el mismo proceso a lo que hiciste\
\
#DisSu14 ex15\
float* addMatrix(float* a, float* b, size_t n) \{\
\}\
\
\

\f0\fs24 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural
\cf0 \
\
\
}